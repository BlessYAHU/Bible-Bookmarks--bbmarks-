bbmarks.Views.Edit = Backbone.View.extend({
    //el: $(''),
    initialize: function(params) {
        this.reset = params.reset || function(){};
    },
    render: function() {
        //var compiled_template = _.template(this.template);
        //this.el.html(compiled_template(this.model.toJSON()));
        //This view doesn't create new markup via a template, but uses the
        // existing markup generated by item view, to hook events and hide/show.
        //question: should this view create this markup? how to hide edit (on cancel) and show details from
        //other view?
        this.el.removeClass('hide');
        console.log(this.model.Name);
        this.$('.name').val(this.model.get('Name'));
        this.$('.description').val(this.model.get('Description'));
        return this; //recommended as this enables calls to be chained.
    },
    events: {
        'click .save':  "saveUpdate",
        'click .cancel' : "cancel"
    },
    saveUpdate: function() {
        this.model.save({Name: this.$('.name').val(), Description: this.$('.description').val()});
        //8/25/11 - Since I haven't gitted this - I binded the model change event to the item view's render event,
        // the code below wasn't needed. Now rendering the data can stay in the item.
        //var bkmrkItm = new bbmarks.Views.Item({model : this.model});
        //this.el.html(bkmrkItm.render().el);

    },
    cancel: function(event) {
        this.el.addClass('hide');
        //8/25/11 - creating a custom event on the model to reset it's view has removed the need to pass a function
        // from the item view to this view to do it.  Awesome.
        this.model.trigger('resetView');
    }
    //etc
});
